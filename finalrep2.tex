%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twoside,twocolumn,12pt]{article}

\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.5} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=25mm,columnsep=20pt,left=25mm]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{5584F $\bullet$ May 2020 $\bullet$ Harvey Hughes} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{graphicx}
\graphicspath{ {images/} }

\newenvironment{reusefigure}[2][htbp]
  {\addtocounter{figure}{-1}%
   \renewcommand{\theHfigure}{dupe-fig}% If you're using hyperref
   \renewcommand{\thefigure}{\ref{#2}}% Figure counter is \ref
   \renewcommand{\addcontentsline}[3]{}% Avoid placing figure in LoF
   \begin{figure}[#1]}
  {\end{figure}}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{pdfpages}
\usepackage{array,multirow,graphicx}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

\newcommand{\threepartdef}[6]
{
	\left\{
		\begin{array}{lll}
			#1 & \mbox{: } #2 \\
			#3 & \mbox{: } #4 \\
			#5 & \mbox{: } #6 \\
			0 & \mbox{: } otherwise
		\end{array}
	\right.
}
\usepackage{multicol}
\usepackage{stfloats}
\makeatletter
\g@addto@macro{\UrlBreaks}{\UrlOrds}
\makeatother
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Robotic Unicycle} % Article title
\author{%
%\textsc{Final Report} \\
%\\
\textsc{Harvey Hughes} \\
\textsc{Supervisor:Professor Carl Rasmussen} \\
}
\date{\today} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%

}

%----------------------------------------------------------------------------------------

\begin{document}
\onecolumn
% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS

\section*{Technical Abstract}
The application of machine learning to determine effective controllers opposed to using control theory could prove to be highly useful when its not possible to determine system dynamics. This would mean new complex tasks could be tackled with minimal knowledge about system behaviour.  A robotic unicycle is considered in this project to provide a complex enough problem to fully test the PILCO algorithm. While successful in simulations, real success on unicycle models has been more challenging. 
\newline
\newline
This project builds upon previous students work dating back to 2005. Throughout the projects history the unicycle being tested has evolved from a large and dangerous model, to a smaller model five years ago. in addition to model change different control algorithms have been used and extensively built up. 
\newline
\newline
The last two years of project work has seen significant improvements and simplifications to the software and electronics. This helped to pinpoint bottle-necks in the learning process but unfortunately the smaller unicycle showed great difficulty at balancing.
\newline
\newline
Speculation that the unicycle roll limit of $17^{\circ}$ impeded learning was thoroughly investigated among additional variables by running simulations. The simulations showed that a mechanical redesign is necessary for learning to occur. This design aimed to upgrade and simplify the physical robot to match the progress made in electrical and software. The new design has a roll limit of $47^{\circ}$, softens fall impact and reliably attaches all sensors. 
\newline
\newline
Numerous problems were found in the old communications methods between phone, computer and Raspberry Pi. These problems introduced large variation in delay between readings, and operated too slowly to provide sufficient learning. For sufficient learning a frequency above 20Hz was shown to be required. To solve these issues and provide additional simplicity UDP protocols were implemented for all transmissions. Unifying all transmissions this was enables the possibility of removing a computers involvement should it be desired in future.
\newline
\newline
Upon starting rollouts further problems were located and fixed. The initial orientation was measured to remove offsets created in the dynamics being learnt and therefore improve accuracy. Trajectories end when the unicycle hits the ground, this detection proved to be unreliable and rollouts became invalid. Additional constraint checks involving future predictions were implemented in addition to manual confirmation.
\newline
\newline
Unfortunately few rollouts were conducted due to problems charging the battery during the Covid-19 lockdown. The rollouts performed demonstrated........
\newline
\newline
During simulations and real rollouts policy optimisation often plateaued, or only learnt to wander instead of stay at the origin. The implementation of a quadratic controller and policy exploration techniques is believed to alleviate these issues.
\newline
\newline
Future work should seek to investigate these issues, taking advantage of the updated and simplified mechanical, electrical, and software systems to identify key requirements. 

\onecolumn

%----------------------------------------------------------------------------------------
\tableofcontents

\twocolumn


\twocolumn[\section{Introduction}]
\begin{figure*}[b!]
  \centering
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth,height=7.5cm]{first}
   \caption{1st model \cite{roderigo}}
  \label{sub:old1}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth,height=7.5cm]{old_unicycle}
    \caption{2nd model \cite{eric}}
  \label{sub:old2}
  \end{subfigure}
  \caption{Previous unicycle iterations}
  \label{fig:unimodels}
\end{figure*}
\subsection{Project aims}
\lettrine[nindent=0em,lines=3]{T}he aim of this project is to determine a controller that is able to balance a robotic unicycle. The controller starts off with no information about the system, and is therefore required to slowly learn what are good actions to make. This mimics the way in which humans learn new tasks as children by trying new actions and seeing if they're beneficial.
\newline
This is an ongoing project in the engineering department, dating back as far as 2005. In previous years success has been shown in simulations yet has so far been hard to achieve in real life. A major outcome of this project is to build upon existing  work and redesign key elements of the unicycle. These redesigns hope to shrink the difference in success between real and simulated tests. 
\newline
This project aims to demonstrate the effectiveness of implementing the PILCO algorithm \cite{pilco} on more complex dynamic systems. PILCO has previously been shown to tackle simpler problems such as a cart-pole system with high efficiency compared to other algorithms. 
\newline 
A unicycle is a suitable example to test on due to the complex nature of the problem, even for human riders. Balancing on the spot is additionally a less linear and therefore harder problem to solve then simply moving forward. This complexity allows the full extremes of the PILCO algorithm to be explored and therefore demonstrate all flaws and benefits of PILCO.
%---------------------------





\subsection{Previous work}
Work has been conducted on robotic unicycles within the engineering Department on and off since 2005 \cite{original}. This unicycle was full sized at 1m, and weighed 35kg shown in figure \ref{sub:old1}. Built by Mellors and Lamb the unicycle incorporated a wheel motor and horizontal flywheel motor which mimics the rotation arms can create while riding. Orientating the flywheel in the horizontal plane  rater then the vertical plane increases the task complexity as the coupling of both motors is required to correct roll errors.
\newline
The problem was originally being solved using control theory approaches. This involved complex analysis of the dynamics in 2D and 3D conducted in 2007-2009 by D'Souza-Mathew \cite{neil} and Forster  \cite{forster}. Some success was demonstrated at balancing the unicycle. However, simplifications in the analysis resulted in non-linearities present in real life to not be considered accurately, therefore reducing performance.
\newline
In 2010 Mchutchon \cite{mchut} applied the RMLC (Reinforced Model Learnt Control) algorithm developed by Rasmussen and Deisenroth to the unicycle, and archived balancing of a unicycle with stabilisers. In 2011 building upon Mchutcons work Queiro \cite{roderigo} and Douglass \cite{douglass} were able to modify the unicycle to balance unrestrained for up to 5 seconds. 
\newline
The size of the unicycle posed serious safety risks, both in terms of large power usage and the need to limit the unicycle during tests. One way this was done was by attaching to bike racks \cite{neil} or suspending the unicycle from the department atrium ceiling \cite{roderigo}. These methods while reducing the risk didn't eliminate it, and caused unnecessary restrictions and disturbances to the unicycle dynamics. 
\newline
To increase safety a small model unicycle was constructed in 2015 by Tukiainen \cite{tuk} as in figure \ref{sub:old2}. PILCO was also implemented on the unicycle \cite{pilco}. The increased safety of the smaller unicycle allowed unconstrained motion to be tested more easily. Problems balancing the unicycle longer than 2s were encountered at this point, with concerns about identifying the cause for problems. In 2017 an overhaul of the software was done by Wieser \cite{eric}, and in 2019 an electrical overhaul by Harris \cite{arsalan}. This was to simplify the system and allow for more accurate troubleshooting. 
\newline
At the project start the pre-existing work consisted of: Small model unicycle with Rasperry Pi electronics and phone sensor, and updated PILCO toolbox including simulation model of unicycle model. The current state of unicycle is discussed in more detail in section III. 
\begin{figure*}[t!]
  \centering
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth,height=7.5cm]{other1}
   \caption{\cite{other1}}
  \label{sub:oother1}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth,height=7.5cm]{other3}
    \caption{\cite{other2}}
  \label{sub:other2}
  \end{subfigure}
  \caption{Other Unicycle designs}
  \label{fig:otheruni}
\end{figure*}

%---------------------------
\subsection{Examples of other unicycles}
There are numerous examples of other balancing robotic unicycles. Many designs included a large vertical flywheel and use of control theory as seen in figure \ref{fig:otheruni}. Orientating the disk this way improves stability and was therefore proved successful at balancing. The improved stability is due to uncoupling the two torques, meaning that to correct a roll error just the flywheel can be used, and to correct a pitch error only the wheel needs rotating. A combination of both actions is required to fix roll errors on a unicycle with horizontal flywheel.
\newline
However, examples of unicycles with a horizonal flywheel can still be found. \cite{other3}  Vos and Von Flotow analysed a large unicycle with this set-up and were able to balance to some success using control theory. This required multi region control policies to work, and therefore was very complicated.
\newline
The robotic unicycles discussed so far have all been developed using traditional control theory. Very few unicycles have been controlled with a machine learning approach. Simulations of a 2D unicycles were successfully balanced \cite{other4} using standard keras and Tensorflow libraries. However, this approach simplifies the problem back to the much easier inverted pendulum, and additionally didn't deal with the problems associated with real rollouts. The lack of previous success at this particular task highlights its difficulty.

%------------------------------------------------
\clearpage
\twocolumn[\section{Theory}]
\subsection{Coordinate System}
In order to fully define the unicycle state at each time step seven coordinates and their derivatives are required. These coordinates are shown in figure \ref{fig:ang} giving the state as

\begin{align*}
\textbf{x} = [\dot{x} \: \dot{y}\: \dot{\theta}\: \dot{\phi}\: \dot{\psi}_f\: \dot{\psi}_w \:\dot{\psi}_t \: x \: y \: \theta \: \phi \: \psi_f \: \psi_w \: \psi_t]^T
\end{align*}


\begin{figure}[h]
  \centering
  \begin{subfigure}[t]{0.1935\textwidth}
    \includegraphics[width=\linewidth]{end_labled2}
  \label{fig:e}
  \end{subfigure}
  \begin{subfigure}[t]{0.2295\textwidth}
    \includegraphics[width=\linewidth]{side_labled}
  \label{fig:s}
  \end{subfigure}
  \caption{Angles used to define position}
  \label{fig:ang}
\end{figure}

In order to define rotations in 3D to represent $\theta,\phi,\psi_f$ correctly care must be taken to the order the rotations are applied. This is because rotations are non commutative in 3D unlike in 2D. The convention of Euler angles is used to solve this problem. \cite{eric}
\newline
There are 12 orders of rotation which can be used. XYZ or 123 convention is used on the unicycle as in equation \ref{eq:eul}. Where $R_A(\alpha)$ represents a right hand rotation about axis A of $\alpha$. 

\begin{equation}
R_{XYZ}(\psi_f,\theta,\phi)\textbf{x} = R_X(\psi_f)R_Y(\theta)R_Z(\phi)\textbf{x}
\label{eq:eul}
\end{equation}

%-------------------------------
\subsection{Quaternions}
As discussed previously rotations in 3D are difficult to combine due to their non-commutative nature. A handy way of dealing with consecutive rotations is to use quaternions. These are an extension of complex numbers to include three imaginary parts and are written as:

\begin{align*}
a + b\textbf{i} + c\textbf{j} + d\textbf{k}
\end{align*}

The following properties ensure quaternions obey the same mathematical rules as 3D rotations:

\begin{align*}
\textbf{i}^2 = \textbf{j}^2 = \textbf{k}^2 = \textbf{ijk} = -1
\end{align*}

A rotation about axis (x,y,z) by $\alpha$ can be defined using the following unit quaternion. 

\begin{gather}
\textbf{q}_{rot} = cos(\frac{\alpha}{2}) + sin(\frac{\alpha}{2})(x\textbf{i} + y\textbf{j} + z\textbf{j}) \nonumber \\
\end{gather}

When post multiplied by the current state quaternion, the new updated position is calculated: $\textbf{q}_{new} = \textbf{q}_{old} . \textbf{q}_{rot}$.
\newline
The angle rotated during each time step can be easily found using the magnitude and direction of the angular velocity multiplied by timestep: $ \theta = | \boldsymbol{\omega} |\delta t$.  \cite{arsalan}
\subsection{Gaussian Processes}
\begin{figure}[h!]
  \centering
    \includegraphics[width=\linewidth]{gp}
   \caption{Fitting a GP to noisy observed data (not from unicycle)}
  \label{fig:gp}
\end{figure}
A Gaussian process is used to model the dynamics and gives a range of possible functions which fit observed data in a non parametric way as to not introduce model bias as in figure \ref{fig:gp}. A Gaussian process is a generalisation of a multivariate Gaussian to infinitely many variables. This can be through as each position having a mean and variance, s a result a mean and covariance functions are used to define it as in equation \ref{eq:gp}.
\begin{equation}\label{eq:gp}
\begin{gathered}
f(\textbf{x}) \sim \mathcal{GP}(m(\textbf{x},k(\textbf{x},\textbf{x'})) \\
m(\textbf{x}) = \mathbb{E}[f(\textbf{x})]  \\
k(\textbf{x},\textbf{x'}) = \mathbb{E}[(f(\textbf{x})-m(\textbf{x}))( f(\textbf{x'})-m(\textbf{x'}))]
\end{gathered}
\end{equation}
A GP eliminates model bias as a group of functions are fit to the observed data. This ensures that all possible solutions to the dynamics are considered, with the most probably functions taking precedence in predictions.


%----------------------------------
%--------------------------------------------------------


\subsection{PILCO}
In policy optimisation an algorithm called PILCO \cite{pilco} will be used.
PILCO is an example of an optimum control algorithm. These algorithms will optimise a policy to decide the best action $\textbf{u}$ given the unicycles state.
Optimum actions are determined by evaluating the expected loss over a horizon under the current policy, as in equation \ref{eq:pilco}. 

\begin{equation}
\begin{split}
\pi^*(\textbf{x}) = argmin \sum_0^tc(\textbf{x}^{(i)}) \\
\textbf{u}^{(i)} = \pi(\textbf{x}^{(i)} )\\
\end{split}
\label{eq:pilco}
\end{equation}

Trajectories are predicted using a GP dynamic model. The use of this model helps to increase the data efficiency of optimisation compared to model free methods such as Q-learning and temporal difference learning. This ensures that minimal rollouts are required which is a major aim of PILCO.

\begin{figure}[ht!]
  \centering
  \begin{subfigure}[t]{0.5\textwidth}
    \includegraphics[width=\linewidth]{u2}
  \caption{x Prediction} 
  \label{sub:ffffffs}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\textwidth}
    \includegraphics[width=\linewidth]{loss2}
  \caption{Loss prediction}
  \label{sub:ffs}
  \end{subfigure}
  \caption{State distribution predictions made using PILCO. The darker region represents an updated prediction using the data collected from the green rollout.}
  \label{fig:pilco}
\end{figure}
%-----------------------------------
A major advantage of PILCO is the ability to retain uncertainty throughout this process. This means an initial state distribution can be propagated forward to generate a state distribution at each time step. These distributions are used to calculate the average instantaneous cost in policy evaluation.
The uncertainty grows over time and comes from an initial variation in start position, measurement noise, and process noise. 
\newline
Figure \ref{sub:ffffffs} shows predicted x position, with predictions up to 0.5s showing low uncertainty. After this the model loses the ability to predict the state accurately and the state distribution widens. 
A similar trend is observed for the predicted loss at each time step in figure \ref{sub:ffs}.
\newline
PILCO uses an iterative approach to optimising policy. Initially a random controller is used to get sufficient data for a dynamic model. Policy optimisation and rollouts under the new policies can then occur until the task is either learnt or terminated. 


%---------------------------------------------------------------
\subsection{Cost Function}
A cost function is required to evaluate the performance at each timestep. This takes the form of equation \ref{eq:simple}. Where a, h and $\theta_{max}$ represent positive constants, and d(\textbf{x}) is the geometric distance of the unicycle tip from the starting position.


\begin{equation}
\label{eq:simple}
\begin{gathered}
c(\textbf{x}) = 1 - \mathcal{R}(\textbf{x}) \\ 
\mathcal{R}(\textbf{x}) = exp(-\frac{a}{2h^2}d(\textbf{x})^2 - \frac{\phi^2}{2(4\pi)^2} - \frac{\theta^2}{\theta_{max}^2}) 
\end{gathered} 
\end{equation}

The cost function is how good actions are justified. For this reason as little information as possible about the dynamic system in question should be imparted vie this function. A purely geometric function using only d(\textbf{x}) was originally used. However, to limit excessive spinning in yaw, and reduce the effect of a small roll limit; the latter two terms were added.
\newline
Other forms of cost function may be used such  quadratic. The reason the exponential function was chosen was to take advantage of its saturation at +1. This provides a clear maximum cost and ensures that far away points don't dominate. This is especially important as a distribution is used to calculate costs, meaning distant points will have some probability of occurring. 
%------------------------------------------

\clearpage
\twocolumn[\section{Current Unicycle Set-up}]
\begin{figure*}[hb!]
  \centering
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth,height=7.5cm]{uni_old_mech}
   \caption{Frame}
  \label{sub:frameold}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth,height=7.5cm]{old1}
    \caption{Front \cite{arsalan}}
  \label{sub:frontold}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth,height=7.5cm]{old2}
    \caption{Back \cite{arsalan}}
  \label{sub:backold}
  \end{subfigure}
  \caption{Current set-up of unicycle}
  \label{fig:current}
\end{figure*}

%\section{Current Unicycle Set-up}
\subsection{Mechanical}
Figure \ref{sub:frameold} shows the mechanical design of the unicycle. The unicycle is constructed from PCB boards made of copper coated fibreglass and subsequently welded together. This material is very light and stiff and helped keep the overall weight to about 1.2kg. The unicycle stands at 20cm tall in real life.
\newline
Two identical motors are used on the unicycle, these are Maxon 110134 \cite{motor}. These motors have maximum continuous torques of 6.31mNm and speeds of 3550rpm. To decrease output speeds, increase torque output and sensitivity; a 14:1 planetary gearhead \cite{gear} is attached to each motor. An additional 40:16 gear and belt system is attached to the wheel to further help. Resulting in maximum output torques of 0.205Nm and 0.513Nm for the turntable and wheel respectively. Each motor has an attached encoder which pulses 512 times per revolution, this can be used to accurately track the motor positions but is currently not in use.
\newline
The flywheel of the unicycle is mounted horizontally and cased within the frame to prevent injury and damage to the motors.
\newline
To prevent damage to the unicycle when falling a basic protection of foam was added to the unicycle. The unicycle currently crashed when a roll angle of $17^{\circ}$ or pitch of $75^{\circ}$ is achieved. The foam didn't stop the initial impact, only when the unicycle later rolled over. 
\subsection{Electrical}
The electrical components on the unicycle were simplified by Harris \cite{arsalan} to only involve a phone, Raspberry Pi and Raspberry Pi motor board. This simplification was to reduce the number of components brought together for successful rollouts, helping reduce complexity and increase ease of troubleshooting. 
\newline
The phone is used to take advantage of high quality sensors existing in a device most people own. The on-board gyroscope is used to update the current state, with the possibility of using the other sensors such as accelerometer to calculate initial position. 
\newline
The Rasberry Pi is used to control the motor torques via the attached motor board. This replaced a normal micro controller and was chosen to allow future adaptability in design as a Raspberry Pi has lots of additional functionality over a micro controller such as wifi.
\newline
Attaching the phone and Pi involved rubber bands. This introduced lots of additional noise as the sensor could move between rollouts or during a rollout, therefore effecting the generalisation of learnt dynamics to all rollouts. To minimise this problem the phone was realigned by attaching and reattaching before each trial. 
\begin{figure*}[t!]
  \centering
    \includegraphics[width=\linewidth]{pilco}
   \caption{Information displayed during rollouts. The state window shows the trajectory of 10 rollouts under the current policy, with each rollouts loss visible in the loss window. Predictive state distributions and updated predictions after an additional rollout are shown as light blue and dark blue regions respectively. The animation displayed corresponds to the green trajectory, which is used in training. Previous policy optimisations can be seen in the policy window.}
  \label{fig:pilcoscreen}
\end{figure*}
\subsection{Software}
The main body of code is run in Matlab on an attached computer. This code is part of the extensive PILCO toolbox, the following steps are required when programming a scenario in PILCO, with each step using the structures and methods defined in the package.

\begin{itemize}
\item Define all state variables, and their use in policies, ode solvers, and dynamics models
\item Number of rollouts to optimise policy over 
\item Number of random rollouts
\item Horizon time
\item Initial state distribution
\item Policy structure, and optimisation methods
\item Plant information including simulation dynamics
\item Controller structure
\item Dynamics function structure and optimisation
\item Cost function
\item Optional policy exploration methods
\item Iterations of learning dynamics from new rollouts, then re-optimising policy function for future use can then occur
\end{itemize}

Figure \ref{fig:pilcoscreen} shows the information generated during rollouts. Shown in these plots is  states, loss, unicycle animation, and policy improvements between iterations. Checks into current performance can be made on the fly. Multiple rollouts are displayed to get a better idea about the behaviours exhibited by the controller, and to check the chosen rollout is typical. 
Policy learning can be analysed by looking at the policy window. This displays the expected loss, optimized 100 times, for each policy iteration. A horizontal line, or grouping of consecutive policy lines can indicate a reduction in learning rate. Often when little data has been observed the trajectory predictions can be overly optimistic, causing the predicted loss decrease rapidly in some iterations. This prediction is later reverted once more data has been observed.
\newline
Additional features such as replaying an animation can be performed by right clicking the desired trajectory line in the GUI, described in detail in by Weiser \cite{eric}. 
Log files are generated of each rollout to allow for easy post processing or reusing old data on modified algorithms.
\newline
During rollouts sensor readings from the phone are logged and used within Matlab by using a now discontinued feature of Matlab mobile. This feature allowed the connection of a phone and computer logged into the same Matlab account to share data eg sensor readings over wifi.
\newline
Position calculations and subsequent policy evaluations were then performed within Matlab to determine motor torques. Motors were controlled using the following commands \cite{arsalan} \cite{motorcmd}: 
\begin{itemize}
\item system(mypi, 'sudo python m/enabling\_motors.py')
\item system(mypi, 'sudo python m/motor\_contorl\_2.py -240 120')
\item system(mypi, 'sudo python m/disabling\_motors.py')
\end{itemize}
These commands opened a command terminal on the Pi through Matlabs integration to Pi package. In this terminal python files could then be executed to turn motors on/off, or change speeds.
%----------------------------------

\clearpage
\twocolumn[\section{Initial Simulation Results}]
\begin{figure*}[hb!]
  \centering
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth]{average_angle}
   \caption{Average time upright across 6 tests}
  \label{fig:a}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth]{disp_angle}
    \caption{Performance variation ($\pm \sigma$)}
  \label{fig:sd}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth]{average_angle_loss}
    \caption{Using average loss as metric}
  \label{fig:rl}
  \end{subfigure}
  \caption{Simulating the effect of roll limit $\theta_{max}$ on learning rate }
  \label{fig:rolllimit}
\end{figure*}
%\section{Initial Simulation Results}
The following section discuses results obtained through simulations. While performance between real life and simulations is greatly different, these simulations proved invaluable. They enabled faster and easier testing of various model parameters in order to evaluate unicycle design choices.
%-------------------------------
\subsection{Test Procedure}

Two different measures will be used to determine success. The first being time upright as more rollouts occur. This is to determine any success at balancing the model has. The second is total rollout loss in order to see if success is achieved by staying near the origin instead of staying upright.
%......................................................
\subsection{Roll Limit}

The first factor that would determine the benefit of a large mechanical redesign is the roll limit. In the unicycle model the roll angle cannot exceed $17^{\circ}$. This is thought to inhibit learning as initially the system can't balance and will hit this limit within very few time steps. This could mean the model has insufficient data to successfully learn a policy. Furthermore as the last measurement is removed in real trials due to high accelerations the data available is reduced more. This reduction will have a larger effect on small roll limits due to scaling in the cost function and can cause failure to appear to happen at a low cost. Which could in turn inhibit learning more.
\newline
Several designs were sketched to change the roll limit. $42^{\circ}$ could be achieved with a new chassis and the same gears, $47^{\circ}$ by changing an additional bracket, and $50^{\circ}$ by increasing wheel size. Simulations of these can be seen in figure \ref{fig:rolllimit}.
\newline
After 10 random rollouts the roll limit made little difference as in figure \ref{fig:a}. However, when policy optimisation started then a higher roll limit improved success greatly. The improvement between 42 and 47 degrees appears significant, a larger change to $53^{\circ}$ caused learning to favour remaining near the origin instead of staying upright and moving away. This different learning method is also good because it shows that a larger limit allows new potentially more successful options for the optimiser. The plateau observed in tests is due to some tests consistently staying upright for the whole horizon time. When looking at rollout total loss in figure \ref{fig:rl} the same pattern is observed with a higher roll limit reducing the overall rollout loss.
\begin{figure}[h!]
  \centering
  \begin{subfigure}[t]{0.5\textwidth}
    \includegraphics[width=\linewidth]{all_angle}
   \caption{Vary roll limit}
  \label{fig:wxro}
  \end{subfigure}
  \newline
  \begin{subfigure}[t]{0.5\textwidth}
    \includegraphics[width=\linewidth]{all_wheel}
    \caption{Vary wheel size}
  \label{fig:exwh}
  \end{subfigure}
  \caption{Simulated performance of each test as total experience changes}
  \label{fig:exti}
\end{figure}
The variation between simulations can be seen in figure \ref{fig:sd} and shows greater reliability at higher roll limits, with a standard deviation of spread at $47^{\circ}$ close to being higher then the mean at $42^{\circ}$. The spread is very important to create a reliable policy training method. The variation at $53^{\circ}$ can once again be explained by some iterations learning to balance at the origin.
\newline
Figure \ref{fig:wxro} shows the performance against simulation time. This is to see if the greater performance is mainly due to additional data, and therefore better dynamics modelling. All the plots give similar results, with the most successful trials balancing for 2.5s with only 20s of experience. Interestingly there are a few tests at $53^{\circ}$ performing as badly as at $17^{\circ}$. This is due to the different balancing technique learnt, which follows a slower learning rate.
%--------------------------------------------------
\subsection{Wheel Size}
\begin{figure}[h]
  \centering
    \includegraphics[width=\linewidth]{disp_wheel}
  \caption{Performance distribution ($\pm \sigma $) when roll limit is $53^{\circ}$, and wheel size changes. }
  \label{fig:whellsi}
\end{figure}
When testing a roll limit of $53^{\circ}$ the change in wheel size wasn't considered. A larger wheel is required for designs at this limit, and their effect must be determined. A larger wheel may effect performance as it increases torque output, and improves sensitivity. Simulations using 35 and 40mm wheels are shown in Figure \ref{fig:whellsi} and \ref{fig:exwh}. Evidently small changes to wheel size have no effect on learning rate as their difference can be explained by rollout randomness. For this reason the 35mm wheel at $47^{\circ}$  roll limit appears the best choice of design.
%-----------------------------------
\subsection{Sampling Time}
Sampling time is another important factor to consider when optimising the training situation of the real unicycle. However, this is a non-trivial parameters and therefore a faster rate would effect the following:

\begin{itemize}
\item Dynamic modelling; dynamics change slower and more linearly between readings, decreasing modelling complexity and improving predictions.
\item Increased optimality; a zero order hold controller is used on the motors, with torque calculated at the start of a step. As the unicycle moves this action is non optimum, therefore an error is introduced.
\item Additional data; this can help build better models but at the expense of extra computational time.
\item Increased measurement noise; every policy call injects noise into the predictions from process and measurement noise. This can cause a more uncertain trajectory prediction over the horizon time.
\end{itemize}

\begin{figure}[h!]
  \centering
  \begin{subfigure}[t]{0.5\textwidth}
    \includegraphics[width=\linewidth]{all_ts}
   \caption{Tests viewed individually}
  \label{fig:allts}
  \end{subfigure}
  \newline
  \begin{subfigure}[t]{0.5\textwidth}
    \includegraphics[width=\linewidth]{disp_ts}
    \caption{Performance distribution ( $\pm \sigma$)}
  \label{fig:dispts}
  \end{subfigure}
  \caption{Simulating timesteps effect of performance}
  \label{fig:st}
\end{figure}
Figure \ref{fig:st} shows the results of changing timestep for a roll limit of $42^{\circ}$. The extra computation time at 40ms resulted in tests lasting upwards of 40 hours compared to 4, as a result fewer simulations were conducted.
\newline
With $\delta t$=40ms all trials except one learnt more rapidly. However, the lower performing trial showed promise as it learnt to balance in a different way to all other trials at this roll limit, it prioritised staying at the origin over just staying upright. Due to a limited horizon time the learning at 50ms caught up within 15 policy iterations.
\newline
The current trend suggests that further increasing sampling rate should improve learning. However, due to the complex relationship timestep has an other factors this may not be the case. The injection of noise from additional measurements will eventually outweigh the benefit of better dynamic modelling. This point will greatly depend upon real rollout performance so is hard to determine through simulations.
\newline
These simulations show that a timestep between 40-50ms is likely to be most optimum.  

%---------------------------------------------


%-----------------------------
%------------------------------------------------


%---------------------------------------
\clearpage
\begin{figure*}
\centering
\begin{subfigure}[t]{0.49\textwidth}
    \includegraphics[width=\linewidth]{frontnewt}
   \caption{Front}
  \label{sub:frontnew}
  \end{subfigure}
  \begin{subfigure}[t]{0.49\textwidth}
    \includegraphics[width=\linewidth]{sidenewt}
    \caption{Side}
  \label{sub:sidenew}
  \end{subfigure}
  \newline



\tabskip=0pt
\valign{#\cr
  \hbox{%
    \begin{subfigure}[b]{.49\textwidth}
    \centering
    \includegraphics[width=\linewidth]{backnewt}
     \caption{Back}
  \label{sub:backnew}
    \end{subfigure}%
  }\cr
  \noalign{\hfill}
  \hbox{%
    \begin{subfigure}{.49\textwidth}
    \centering
    \includegraphics[width=.602\textwidth]{botnewt}
     \caption{Bottom}
  \label{sub:botnew}
    \end{subfigure}%
  }\vfill
  \hbox{%
    \begin{subfigure}{.49\textwidth}
    \centering
    \includegraphics[width=.602\textwidth]{topnewt}
     \caption{Top}
  \label{sub:topnew}
    \end{subfigure}%
  }\cr
}

  \caption{New set-up of unicycle}
  \label{fig:new}
\end{figure*}





\begin{figure*}[t!]
  \centering
  \begin{subfigure}[t]{\textwidth}
    \includegraphics[width=\linewidth]{partst}
   \caption{Parts}
  \label{sub:parts}
  \end{subfigure}  
  \newline  
  \begin{subfigure}[t]{0.6\textwidth}
    \includegraphics[width=\linewidth]{buildt}
    \caption{Start of assembly}
  \label{sub:con}
  \end{subfigure}
  
  \caption{Main sheet metal components in new unicycle }
  \label{fig:parts}
\end{figure*}
\clearpage
\twocolumn[\section{Mechanical Redesign}]
%\section{Mechanical Redesign}
Speculations from previous years and simulations results conducted indicated that the unicycle was unable to learn to balance with a roll limit of 17 degrees. This prompted the need for a new unicycle design pictured in figure \ref{fig:new} and \ref{fig:parts}. In order to allow for a good design the following principles were adopted:

\begin{itemize}
\item Replace welding with bolts, to allow for easy part replacement if required in future
\item Maintain rigidity when switching to bolts
\item Keep parts as simple as possible
\item Allow for variation in parts eg phone size
\end{itemize}

\subsection{Changes}
\subsubsection{Roll limit}
From simulations it was shown that increasing the roll limit to $47^{\circ}$ was required for learning to be possible. Increasing the limit much further was deemed unnecessary by simulations.

\begin{figure}
  \centering
    \includegraphics[width=\linewidth]{place}
  \caption{New design for higher roll limit, demonstrating limit change from $17^{\circ}$ to $47^{\circ}$} 
  \label{fig:newline}
\end{figure}

Figure \ref{fig:newline} shows a comparison between the old $17^{\circ}$ design and new $47^{\circ}$ design. This was made possible using mostly the same parts from the original design, with the exception of bearings. This was to maintain the gear ratio shown to be effective, and to reduces the need to source new parts that would make very marginal differences. 
\newline
The first step to increasing roll limit was to bring the gears and motors as central as possible. This required decentralising the motor position and therefore CoM. The unicycle would still be able to learn with an off-centre design. However, this is corrected for with off-centred Pi mounting. Once all the parts had been centralised it was found that the roll limit was $42^{\circ}$ with the axle bracket being the limiting factor. 
\newline
Three steps were implemented to reduce this limit. Reduce size of bearing holder, use smaller 10x6mm bearing, and minimise size of axle mount. These changes allowed the roll limit to become $50^{\circ}$ as desired, with the extra $3^{\circ}$ to allow for ample deceleration by the new protection system.  
%--------------------------------------
\begin{table*}[ht!]
\centering
\begin{tabular}{ c | c | c | c | c | c}
Design& Simplicity & Wear & Damping &Replacing & Total\\ 
\midrule
1&5 &3 &3&5&\textbf{16}\\
2&1& 4&4&3&12\\
3&4&3 &4&3&14\\
\end{tabular}
\caption{Protection system analysis. With each category scored out of 5}
\label{tab:pro}
\end{table*}

\subsubsection{Protection}
The next problem to solve was protecting the unicycle from the many falls it would experience. To be effective this would need to decelerate the unicycle at a slow rate, be easy to attach and fix if damaged, be mounted to not decrease the roll limit by too much.
\newline
Three designs were proposed, an evaluation of which can be seen in table \ref{tab:pro}. Design one consisted of a static material eg rubber or foam being attached, design two was a large ring attached to the main chassis by springs, and design three used an inflated inner tube. The design that proved to be the most effective at achieving the initial aims was a static material damper. This was due to its simplicity and ease of replacement, while still maintaining effectiveness. To decide the material various items were tested by hand. These were rubber tubing, foam insulation tubing, hose pipes, and silicon seals. Out of these materials only the foam tubing was the desired stiffness and thickness for the task. The tubing came with the added benefit of being the cheapest and has the option to increase stiffness if required by threading extra material inside it.

\begin{equation}
d =\frac{h-\frac{r}{2}}{tan\theta} - \frac{r}{2} - \sqrt{r^2-\frac{t^2}{4}} = 86mm
\label{eq:diskdia}
\end{equation}

The foam was to be mounted to the horizontal metal disks protecting the flywheel. A roll limit of $47^{\circ}$ was designed for the point of contact on the tube allowing for $3^{\circ}$ of deceleration to occur. This corresponded to a displacement of 8mm in the foam. The required disk diameter was approximated using equation \ref{eq:diskdia}. Where t=26mm is the disk separation, r=15mm is the foam radius and h=115mm the height of the midpoint between disks.

%--------------------------------------
\subsubsection{Mountings}
The previous method of mounting the phone used elastic bands. This resulted in lengthy repositioning of the phone between trials to minimise noise introduced by sensor position change. A design aim was to decrease this variation by providing a secure mounting that was capable of fixing any phone, in case this changed in the future. 
\newline
To have reliable and repeatable phone position the attachment must resisting all degrees of freedom and have at least 3 reference planes for repeatable phone alignment. Due to these strict requirements and desire for size variability it was decided to use an existing phone mounting system. This would increase part size, but provide the desired functionality without needing to fabricate complicated parts. Different bike and car mounts were evaluated with the Greyfay PB04AC bike mount eventually chosen \cite{bike}. This mounts onto a handlebar like design at the top of the unicycle as in figure \ref{sub:topnew}. 
\newline
The Raspberry Pi was attached using long bolts located on the opposite side to the phone. In addition to the battery these were located slightly off centre, see figure \ref{sub:backnew}. This countered the off centred motor position for the wheel, and successfully brought the CoM to the centre. The Pi was located further away from the central plane of the unicycle then desired, this was due to the inability to find suitably short screws, and spacers because of closures due to Covid-19. By shortening these screws the moment of inertia would reduce and could improve unicycle balance.  
%--------------------------------------
\subsubsection{Material}
On the old unicycle model a copper coated fibre glass was used, as it had high stiffness but low weight. Due to designing within solidworks and requiring some machined parts the EDG office who manufactured the parts last time were unable to help again. Therefore a change in material was required to 1.6mm plate aluminium, with the manufacturing done in the Dyson centre workshop. This ensured that the frame would be stiff enough to limit unwanted vibrations without adding too much weight. 
\subsection{Inertia}
\begin{table*}[ht!]
\centering
\begin{tabular}{ c | c | c | c | c | c | c | c | c | c | c }
&  & &  &  & \multicolumn{3}{c|}{About CoM} & \multicolumn{3}{c}{About ground}\\
&  & &  &  & \multicolumn{3}{c|}{/ x$10^{-5kgm^2}$} & \multicolumn{3}{c}{/ x$10^{-3}kgm^2$}\\
Part& Mass/kg & x/m & y/m & z/m & $I_{xx}$ & $I_{yy}$  & $I_{zz}$ & $I_{xx}$ & $I_{yy}$  & $I_{zz}$ \\ 
\midrule
Phone & 0.2 & 0.06 & 0.7 & 0.2 & 46 & 8 & 38 & 8.5 & 8.7 & 1.0\\
Back Plate & 0.12 & 0 & 0 & 0.12 & 60 & 40 & 20 & 2.3 & 2.1 & 20\\
Disks & 0.1 & 0 & 0 & 0.11 & 19 & 19 & 38 & 2.8 & 2.8 & 0.76\\
Bot Motor & 0.12 & 0 & 0 & 0.09 & 4.6 & 0.7 & 4.6 & 1.0 & 1.0 & 0.05\\
Top Motor & 0.12 & 0 & 0 & 0.15 & 4.6 & 4.6 & 0.7 & 2.7 & 2.7 & 0\\
Axel support & 0.02 & 0 & 0.02 & 0.07 & 0.46 & 2.3 & 1.8 & 0.2 & 0.2 & 0.05\\
Flywheel & 0.2 & 0 & 0 & 0.11 & 8.1 & 8.1 & 16 & 2.5 & 2.5 & 0.16\\
Pi + battery & 0.15 & 0.04& 0 & 0.16 & 14 & 8 & 6 & 4.0 & 4.0 & 0.3\\
Handlebar & 0.067 & 0.015 & 0 & 0.22 & 1.3 & 12 & 1.3 & 3.2 & 3.3 & 0.3\\
Phone holder & 0.1 & 0.02 & 0 & 0.21 & 4.2 & 2.1 & 2.1 & 4.5 & 4.5 & 0.06\\
\midrule
\textbf{Total}
 &  & &  & 
 &  &  &  & 31.7 & 32.1 & 2.64\\
\end{tabular}
\caption{Moment of inertia estimate of parts and unicycle about wheel contact point. Axis defined as x forward, y sideways and z vertically}
\label{tab:mot}
\end{table*}

Table \ref{tab:mot} shows estimations of the moment of inertia of the new unicycle about the ground contact point. The estimations involved approximating each part to be a simple object such as planes, disks or cylinders. Then using the formula from the mechanics data book the inertia about each parts CoM could be calculated and moved by the parallel axis theorem to the contact point. The estimated inertias are 31.7, 32.1 and 2.64 $10^{-3}kgm^2$  for the x,y and z axis respectively. The inertia about the x and y axis are very similar as desired, meaning the unicycle should fall more uniformly in all directions. An estimation on the old unicycle was conducted for $I_{zz}$ \cite{arsalan}, Harris assumed the unicycle was a cylinder and then checked his answer using measured angular accelerations. The value Harris calculated was 2.54$x10^{-3}kgm^2$ which is very similar to the new unicycle model.
\newline
The inertia about the vertical z axis is 16.4 times that of the flywheel. This means that to conserve angular momentum the flywheel needs to spin this much faster then the maximum rate of change in yaw. The motor has a maximum load speed of 3550rpm, after the 14:1 planetary gear this corresponds to a maximum angular speed of 26.5rad$s^{-1}$. Therefore a correction in yaw of up to 1.6rad$s^{-1}$ or a quarter rotation per second is possible. This speed seems high enough to enable learning.
\begin{equation}
\begin{split}
T = mgl sin\theta = I\ddot{\theta} \\
\ddot{\theta} = \frac{mgl}{I}sin\theta\\
dot{\theta} = \frac{mgl}{I}sin\theta t + c_1\\
\theta = \frac{mgl}{2I}sin\theta t^2 + c_1t + c_2\\
t = \sqrt{\frac{2\theta I}{mglsin\theta}} \\
\end{split}
\label{eq:rollt}
\end{equation}
The time required for the unicycle to fall without motor input can be calculated using equations \ref{eq:rollt}. At t=0, $\dot{\theta}$ and $\theta$ = 0. This means that both constants are 0. By assuming the CoM is at l=0.16m and m=1.5kg the time to fall $45^{\circ}$ is calculated to be 1.2 seconds. However, from measuring the unicycle fall this time in reality is nearer to 0.6s. This reduction in time by half is caused by the wheel rolling as the motors were off, therefore the assumption of rotation about the contact point is false, meaning I is reduced. While still present during rollouts this change will be less severe as powering the motors stops them moving freely. This means a falling time between 0.6-1.2s is expected. With a timestep of 50ms this allows 12-24 recordings and commands to be present, even in bad rollouts. When random actions are taken fall time will further reduce as most actions are bad, however not by much since each action is independent from the last so can counter bad actions. Therefore a large improvement on the last unicycle model is expected which initially saw around 3 readings before the $17^{\circ}$limit was reached.

%--------------------------------------
\subsection{Design Evaluation}
While constructing the unicycle it was apparent that the new design was more rigid and adaptable then the last model. Having the flywheel protection disks made out of one piece, instead of two welded together was the main source of this additional strength. The addition of the bolts and extra room also made assembling the model much easier which is promising if future modifications are needed. Some bolts are currently missing due to the inability to acquire more during the lockdown period of Covid-19. The addition of these bolts and ensuring all bolts and cable ties are attached tightly is very important for minimising vibrational noise in future test runs.
\newline
The attachment of the Pi and phone proved very successful, allowing access to all the ports on both devices. The handle bar was a secure way of attachment allowing for adequate variation in either phone orientation or size. Due to the mounting at the top of the unicycle the moment of inertia about the wheel when falling is increased by around 50\%, as seen in table \ref{tab:mot}. This doesn't appear to be adversely affecting the unicycle performance as falling occurs slow enough to react to. To improve this in future weight could be removed from the inside of the handle bar, or mounting holes could be moved lower down the back plate. This movement would also reduce the vibrations carried up this plate, which add unwanted noise to the sensor readings. Once again this problem doesn't appear to be too large and much easier methods of reduction could be implemented such as stiffeners attached to the plate edges.
\newline
The foam protection ring proved to be very effective. Roll angle was only marginally reduced as calculated, and the unicycle is able to safely fall without supervision. This part can easily be replaced by simply buying a new tube \cite{foam} and 7 cable ties.
\newline
Due to a change in material and slightly increase in size the overall weight of the unicycle was increased from 1.2kg to 1.5kg. Inertia calculations and conducted rollouts show that the increase in weight and inertial still allows for good performance. However, if this proved problematic the easiest change would be to introduce a larger flywheel as there is room in the casing, or reposition the phone mounting. A larger flywheel would help increase yaw and roll adjustments, and moving the phone would reduce the largest contributor to $I_{xx},I_{yy}$ and therefore decrease topple speed.  

%--------------------------------------
\clearpage
\twocolumn[\section{Software Changes}]
A number of problems were detected in the software running a real rollout. These faults were constraint detection and state calculation.
\subsection{State Calculation}
Previously state calculations incorrectly assumed wheel and flywheel angular velocities was directly the input torques. A slight correction to include gearing ratio, and no load speed was required to fix this. Additionally x,y position was reset at each measurement and therefore needed correcting.
\subsection{Constraint Detection}
When the unicycle hits the floor the rollout should terminate and trim any readings made after the impact. This is the ensure training occurs on valid dynamic data, and the unicycle can't cause damage while fallen over. It was noted that this detection was unreliable and often failed.
\newline
The process of constraint detection followed: Implement policy \textbf{u}=$\pi (\textbf{x})$ $\rightarrow$ Get measurement $\rightarrow$ Calculate next state, if constraint exceeded then terminate. This caused problems because the constraints are checked under the current state, which is calculated using current $\boldsymbol{ \omega }$ and last $\delta t$. Had the collision occurred between the last two measurements then the current state would be calculated using $\boldsymbol{\omega}$ after an impact, therefore incorrectly calculation angle.
\newline
In order to remedy this error a prediction one step into the future was added. This position was then checked against the constraints and noted for next timestep if exceeded. To check if a collision occurred as predicted $\boldsymbol{\omega}$ is checked against the last position. In the event of a collision the impact would cause large accelerations in approximately opposite direction to before impact. These accelerations would be larger then those possible with a change in torque meaning thresholding could detect collisions.
\newline
This new method greatly improved detection. However, some errors still occurred meaning a manual check was introduced into rollouts to ensure valid data was passed into PILCO. 


 
%\section{Software Changes}

%-----------------------
\clearpage
%\twocolumn[\section{Results}]

%--------------------------------
\clearpage
\section{Results}
\begin{figure*}[hb!]
  \centering
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth]{timestep}
   \caption{Delay between consecutive measurements at sending and receiving ends}
  \label{fig:ts}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth]{delay}
    \caption{Uncalibrated time difference between sender and receiver}
  \label{fig:td}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth]{both}
    \caption{Delay when desired times are 25ms or 50ms}
  \label{fig:ts2}
  \end{subfigure}
  \caption{Testing connection between phone and Matlab using USB}
  \label{fig:usb}
\end{figure*}
\subsection{Phone}
\subsubsection{Connection}
Previously the phone connected to the Matlab scrip on the computer using Matlab mobile and wifi. However, this feature has since been removed from Matlab mobile and delays caused by using wifi were believed to occur occasionally. This could introduce extra noise and incorrect state measurements, therefore decreasing learning ability.
\newline
HyperIMU \cite{ianovir} was used to replace Matlab mobile. This allowed connection using wifi and USB. The transmission protocol followed was UDP using the packet layout:



\begin{align*}
[t, a_x, a_y ,a_z , \dot{\alpha}_x, \dot{\alpha}_y , \dot{\alpha}_z \#]
\end{align*}

UDP was chosen over serial communication protocols to take advantage of existing software and allow for wifi to easily be used again in the future if desired.
\newline
Tests were conducted to determine the reliability of this method. Figure \ref{fig:ts} shows the time between consecutive measurements on both the phone side and computer side. A mean of 50.89ms and standard deviation of 1.27ms was recorded over 1000 measurements. Variation is undesirable but this is small and times are known so won't prove problematic. A similar spread was observed at lower sampling times as shown in figure \ref{fig:ts2} where a 25ms sampling time resulted in a mean of 25.88ms and standard deviation of 1.38ms. This shows that this software is suitable if faster sampling times are required.
\newline
Due to different clocks on the computer and phone true transmission delay wasn't possible to measure. Figure \ref{fig:td} shows this uncalibrated delay. The majority of packets take one of two times to transmit with a few outliers taking $\pm$2ms. A low variation is desirable as it means actions can be applied for the correct length of time, as to not alter the trajectory away from the policy prediction.


\begin{figure}
  \centering
    \includegraphics[width=\linewidth]{all3}
  \caption{Effect of changing transmission medium}
  \label{fig:med}
\end{figure}

\begin{table}[h]
\centering
\begin{tabular}{ c | c | c | c }
Test& USB-A & USB-C & WIFI\\ 
\midrule
1&0.99&1.05 &3.02\\
2&1.24& 1.26&1.25\\
3&1.10&1.02 &1.84\\
\end{tabular}
\caption{Transmission time $\sigma$ in ms}
\label{table:td}
\end{table}
The delay over Three transmission mediums were compared in figure \ref{fig:med}. A smaller number on these graphs corresponds to a faster transmission. It was noticed that the difference between mediums was too large, this was explained when conducting the tests in different orders. The two clock times drifted apart after each test causing the exact delays to be incomparable, therefore flipping test order resulted in the opposite order to the figure. However, the variation in delay is what is most important when deciding method as this is what can cause unexpectedly long applied actions. Wifi showed some delays of nearly a whole time step in figure \ref{fig:med}. The standard deviation was calculated in Table \ref{table:td}. In test two the variation was almost identical amongst methods, but in the other tests wifi again showed greater variation. For this reason either USB connection is a better choice for use on the unicycle. However, the additional noise introduced by an extra cable effecting dynamics  may outweigh the transmission delay advantage and will need investigating. 
%------------------------------
\subsubsection{Orientation}
Imperfect starting positions in real rollouts can cause a constant offset in position throughout tests unless its determined at the start or learnt. Learning the offset is possible when training; however due to the offline nature of rollouts it can't currently be learn on new runs. Measuring the initial orientation is therefore required, which also allows accurate uncertainty measurements ensuring predictions incorporate as much information as possible.
\newline
To calculate the initial orientation the roll and pitch angles between transformed accelerometer reading and vertical, $\textbf{a}_0 = [0,0,-1]^T$ needs to be determined. A transformation is required from the raw sensor acceleration to convert between phone and unicycle co-ordinates, this transformation being:
\begin{align*}
\textbf{a} = \begin{bmatrix}
0 & -1 & 0 \\
0 & 0 & -1\\
1 & 0 & 0 \\
\end{bmatrix}
\hat{\textbf{a}}
\end{align*}
 The unicycle has only two angular DoF initially, this means that one angle can be set to 0. For this we choose yaw as it only depends on the starting position and is penalised when higher. The angles are measured for two seconds before initiating the rollout to estimate initial uncertainty.
\begin{equation}
\begin{gathered}
\delta\textbf{a} = \textbf{a}_0 - R\hat{\textbf{a}} \\
\begin{bmatrix}
\theta \\
\psi_f \\
\end{bmatrix} = 
2 \begin{bmatrix}
tan^{-1} ( \frac{\delta\textbf{a}_x}{\sqrt{\delta\textbf{a}_y^2+\delta\textbf{a}_z^2}} )\\
-tan^{-1} ( \frac{\delta\textbf{a}_y}{\sqrt{\delta\textbf{a}_x^2+\delta\textbf{a}_z^2}} )\\
\end{bmatrix}
\label{eq:con}
\end{gathered}
\end{equation}
Equation \ref{eq:con} calculates the initial euler orientation. This can then be easily converted to quaternion form with two quaternions rotations : (1 + 0\textbf{i}  + 0\textbf{j} + 0\textbf{k})$R_Y(\theta)R_X(\psi_f)$. 
\subsection{Raspberry Pi}
\subsubsection{Connection}

\begin{figure*}[t]
  \centering
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth]{25ms_pi}
   \caption{$\delta$t = 25ms}
  \label{fig:pi25}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth]{50ms_pi}
    \caption{$\delta$t = 50ms}
  \label{fig:pi50}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
    \includegraphics[width=\linewidth]{150ms_pi}
    \caption{$\delta$t = 150ms}
  \label{fig:pi150}
  \end{subfigure}
  \caption{Connection speed breakdown between Matlab and Pi using the Matlab "system" command}
  \label{fig:pi}
\end{figure*}
Connection to the Raspberry Pi is done using the Matlab support package for Pi devices \cite{pi}. An initial set-up is required for this package. Involving connecting the Pi using a Ethernet cable, and following the package installation guide using the Raspberry Pi 3 Matlab image. Once set up the following command can be run in Matlab:
\begin{gather}
mypi = raspi('169.254.0.2', 'pi', 'raspberry') \nonumber
\end{gather}
This assigns the connection to the variable mypi, using the default IP address, username and password. This connection can then be used to send commands with:
\begin{gather}
system(mypi, 'sudo \: python \: m/filename.py') \nonumber
\end{gather}
This command opens a terminal on the Pi and runs the python file specified. Three files were used \cite{motorcmd} "enabling\_motors" , "motor\_control\_2" and "disabling\_motors". These turned on, set motor speed and turned off the motors respectively.
\newline
During testing it became apparent that there was a high degree of variation in time required to change motor speed. This is unwanted because it introduces error to the dynamic model which predicts for a constant timestep. If this variation also resulted in larger timesteps then 50ms the learning ability would be drastically reduced as less data is record initially, and the dynamics are less linear therefore harder to model. Increasing the capabilities of the dynamics model to include variable timesteps was considered. However, this would increase the problem dimensionality therefore the data collected may have to increase to effectively reduce uncertainty.
\newline
Figure \ref{fig:pi} shows this variation occurring when controlling the motors, for a number of different timesteps. Initial recordings took longer in each test, the execution time then settled to be at minimum 90ms, with some spikes up to 160ms. This meant that lots of sensor readings weren't being processed.
\newline
The cause of this delay was found to be the Matlab system command. This command waits for a completed message to be returned before the Matlab script proceeds. Due to the command opening a new terminal, and python file each time it took at minimum 90ms. Possible solutions were tested to avoid this; adding '\&' at the end of a command stops the script waiting for a reply, however this is incompatible when executed through a Pi. The command was also ran as a batch on a sub process, this allowed the script the proceed without delay but didn't successfully control the motors. 
\newline
The implemented solution looked to minimise the need to open a new python script and terminal for each change in motor speed. For this to be implemented UDP was once again used to send motor commands. The use of UDP allows for the future possibility of removing a computers involvement in rollouts as both the Pi and phone communicate with it. A script is ran for the duration of the rollout on the Pi, this listens to a UDP port and actions any commands sent. To initiate this script and avoid the need to wait for a response an alternative to the system command was used:

\begin{gather}
openShell(mypi); \nonumber
\end{gather}

This opens a SSH connection to the Pi and a terminal on the computer. The following command is then run in this terminal to initiate listening on the Pi:

\begin{gather}
sudo \: python \: m/start\_rollout.py  \nonumber
\end{gather}

The terminal confirms a live connection and displays motor commands sent using the following format:

\begin{gather}
[Flywheel \: Speed, \: Wheel \: Speed] \nonumber
\end{gather}

The script is terminated by sending \# in this command, instead of numbers.

\begin{figure}
  \centering
    \includegraphics[width=\linewidth]{50ms_udp}
  \caption{Connection speed breakdown between Matlab and Pi using UDP}
  \label{fig:piudp}
\end{figure} 

Figure \ref{fig:piudp} shows the success this method has at bringing the timestep to the desired length, and reducing the variance in time from 0.038 to 0.017.  Problems still occur for the initial commands which take twice as long, this was fixed by optimising the rollout loop in Matlab ensuring variables are initiated beforehand, thus decreasing calculation time.  

%----------------------------------
\onecolumn
\subsection{Rollouts}
\begin{figure*}[t]
  \centering
  \begin{subfigure}[t]{0.325\textwidth}
  \centering
    \includegraphics[height = 6.5cm]{front_lab}
   \caption{Phone set-up}
  \label{fig:set_up}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
  \centering
    \includegraphics[height = 6.5cm]{hyperimu}
    \caption{HyperIMU settings}
  \label{fig:imuset}
  \end{subfigure}
  \begin{subfigure}[t]{0.325\textwidth}
  \centering
    \includegraphics[height = 6.5cm]{relt}
    \caption{Release position}
  \label{fig:unirel}
  \end{subfigure}
  \caption{Steps in set-up}
  \label{fig:set_up_steps}
\end{figure*}

\subsubsection{Test Procedure}

\textbf{Mechanical Set-Up}
\begin{itemize}
\item Attach phone as in figure \ref{fig:set_up} with the top of the phone facing to the left of the unicycle. Ensure the phone attachment is vertical and secure
\item Attach the Raspberry Pi using an Ethernet cable to the computer running Matlab
\item Connect phone to computer using a USB-A/C cable
\item Connect Raspberry Pi to 5V power source, and attach on board battery
\end{itemize}

\textbf{Software Set-Up}
\begin{itemize}
\item Turn on USB tethering in the phones settings (settings/network and internet/hotspot and tethering). This often works more reliably with the phone in aeroplane mode
\item Find the ipv4 address of the attached computer. On windows this is found by typing ipconfig into a command window
\item Open HyperIMU on the phone and go to settings and enter the IPv4 address, port 5555 and desired sample rate(this is often 1ms too slow) as in figure \ref{fig:imuset}
\item Save these settings and click start logging from HyperIMU
\end{itemize}
\textbf{Rollouts}
\begin{itemize}
\item In an open flat space position the unicycle, and run "doitreal.m" script from the connected computer
\item A SSH window from the computer to the Pi will then open. Typing the command "sudo python m/start\_rollout.py" will initiate listening mode on the Pi, and display all motor torques and time between subsequent messages
\item Ensure the unicycle is held still and vertical, either by holding onto the frame or string as in figure \ref{fig:unirel}
\item The orientation is then measured for a few seconds before the motors start, at this point the unicycle is released
\item After the unicycle has fallen the motors should terminate, and confirmation of a successful rollout is required in Matlab 
\item Policy optimisation and dynamics learning then ensues, the unicycle could be disconnected during this step
\item This is repeated until the desired rollouts are completed
\end{itemize}

\twocolumn
%----------------------------
\subsubsection{Tests}
Due to limited access to the department caused by lockdown, and inability to find the correct cable for the battery charger minimal tests were conducted. The results of these tests can be seen in figure \ref{}. Limited success at balancing was achieved, this is likely attributed to low battery charge and insufficient rollouts performed. It was noticed that in one test the original policy learnt set the flywheel torque to maximum, and only after subsequent optimisations was this changed. This could signify the flywheel is currently too small for the unicycle, and a larger one may be required.

%---------------------------------


\clearpage


%----------------------

\onecolumn
\begin{table}[ht!]
\centering
\begin{tabular}{ c | l }
\multicolumn{2}{c}{Project Changes Timeline}\\ 
\cmidrule(r{4em}){1-2}
\parbox[t]{2mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{Michaelmas}}} & \textcolor{ForestGreen}{$\bullet$} Understand PILCO and its repository \\
& \textcolor{ForestGreen}{$\bullet$} Solve run time error caused by windows \\
& \textcolor{Maroon}{$\bullet$} Draft new unicycle designs \\
& \textcolor{ForestGreen}{$\bullet$} Simulate roll limits \\
& \textcolor{MidnightBlue}{$\bullet$} Redesign and test communication to phone \\
& \textcolor{ForestGreen}{$\bullet$} Implement original state measurement \\
\cmidrule(r{4em}){1-2}
\parbox[t]{2mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{Lent}}} & \textcolor{ForestGreen}{$\bullet$} Simulate wheel size\\
& \textcolor{ForestGreen}{$\bullet$} Simulate timestep \\
& \textcolor{Maroon}{$\bullet$} Evaluate unicycle designs and create CAD model \\
& \textcolor{Maroon}{$\bullet$} Get parts manufactured \\
& \textcolor{Maroon}{$\bullet$} Dismantle old unicycle and assemble new model \\
& \textcolor{MidnightBlue}{$\bullet$} Test motors are working \\
\cmidrule(r{4em}){1-2}
\parbox[t]{2mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{Easter}}} & \textcolor{MidnightBlue}{$\bullet$} Increase motor command execution speed\\
& \textcolor{ForestGreen}{$\bullet$} Correct rollout state calculations  \\
& \textcolor{ForestGreen}{$\bullet$} Improve constraint detection system\\
& \textcolor{MidnightBlue}{$\bullet$} Research methods to incorporate encoders\\
& \textcolor{Maroon}{$\bullet$} Perform real tests\\
& \textcolor{ForestGreen}{$\bullet$} Research exploration techniques and controllers\\
\cmidrule(r{4em}){1-2}
Key &  \qquad	\textcolor{Maroon}{Mechanical} \qquad	
\textcolor{MidnightBlue}{Electrical} 	\qquad
\textcolor{ForestGreen}{Software} \\
\end{tabular}
\caption{Changes made over project duration categorised by design area }
\label{tab:Timeline}
\end{table}

\twocolumn
\twocolumn[\section{Conclusions}]
%\section{Conclusions}


\subsection{Progress}
This project continues on from previous years work. The unicycle was shown to be successful at learning controllers in simulations, but various issues inhibited learning on the model unicycle.   
\newline
The work conducted on this project has taken a variety of forms as mechanical, electrical and software changes were required. A summary of this is seen in table \ref{tab:Timeline}. This can be broken down into simulations evaluating important parameters for learning, mechanical redesign implementing these discoveries and improving old communication systems to reduce noise and variation.
\newline
Initially simulations were conducted to establish the effect certain parameters had on learning. It was found that a new model was required for learning to occur due to the inability to learn at roll limits as low as $17^{\circ}$. Simulations different timesteps also provided additional insight. By reducing timestep from 50ms to 40ms learning occurred with fewer policy iterations, even allowing controllers to learn to balance at the origin and not wander off. The reason for this improvement is due to; increased linearity, additional data, and optimum torques active for longer. However, at 40ms the training time could be 10x longer then at 50ms. For this reason additional experiments should be conducted to determine the best timestep between 40-50ms to compromise speed and effectiveness. 
\newline
As simulations showed inadequate learning on the current unicycle model, a new model was designed. This model would also address problems in fall protecting, sensor stability and repeatable test procedures. The design increased the roll constraint to $47^{\circ}$, increased simplicity while maintaining rigidity. The increased size of unicycle sparked worries about insufficient motor power. However, simple changes could be made to correct this if required.   
\newline
Data communication between Matlab, phone and Raspberry Pi was completely redesigned. Delays in wifi communication and sending motor commands were solved by changing all transmissions to use UDP protocols. An additional benefit of this approach enables direct communication between Pi and phone. This means that in future rollouts could be performed without an attached computer.
\newline
Unfortunately few real rollouts were conducted..


%------------------------------
\subsection{Future Work}
Future work should first seek to evaluate the performance of the new model, as limited rollouts were possible this year. These investigations should aim to determine weather the increased unicycle inertia is holding learning back. If so changes to phone position and flywheel size should be made to reduce this effect.
\newline
The last three years of project work have seen updates to the software, electrical and mechanical set-up. This means the unicycle is now at a point where a variety of factors can be investigated more deeply, to discover what techniques are required for problems of this form when using the PILCO algorithm. 
\subsubsection{Encoder}
Currently the wheel and flywheel angular velocities are calculated using the input torques. This approximates the relationship to be linear, which becomes less true the faster and further from upright the unicycle becomes. This approximation causes inaccuracies in the trained dynamics model introducing process noise, and increases learning complexity. 
\newline
In order to correct this error the motors should be measured directly. This is done using the attached encoders \cite{encoder}. Pulses are generated 512 times per revolution, which under normal motor speeds produces pulse frequencies up to 50kHz.
\newline
Both positive and negative pulses require counting to accurately determine speeds. This could be done using additional hardware or for simplicity interrupt routines on the Pi \cite{interrupt}. The motor states could then be transmitted to Matlab simply using UDP.
\begin{figure*}
  \centering
    \includegraphics[width=\linewidth,height = 8cm]{place}
  \caption{Optimum torque directions for flywheel and wheel in locations spanned by [$\theta ,\psi_f$]}
  \label{fig:quad}
\end{figure*} 
%----------------------
\subsection{State Calculation}
The new communication systems were shown to be equally reliable at faster speeds around up to 15ms. This allows the possibility of calculating current state and constant checking more frequently without decreasing the learnt dynamic timestep.
\newline
This would involve updating the current state multiple times per dynamic timestep. Doing so could increase the state accuracy as dynamics are more linear. however, increasing measurements will introduce more noise which may outweigh the benefit. 
%----------------------------------
\subsection{Quadratic Controller}
All simulations and rollouts conducted so far have used a linear policy control function to determine the best action from the current state as in equation \ref{eq:lin}. There is the question of whether a linear policy is sufficient to control a unicycle. A quadratic policy of the form of equation \ref{eq:quad} may be more suitable.
\begin{equation}
\pi (\textbf{x}) = \textbf{Wx}+\textbf{p}
\label{eq:lin}
\end{equation}
Figure \ref{fig:quad} depicts the optimum action to be taken for the state space covered by [$\theta ,\psi_f$]. This ideal action is the action which minimises the distance or angle moved in that direction to return the unicycle to the desired position of [$\theta ,\psi_f$] = [0,0]. 
\newline
To correct pitch a linear policy is clearly sufficient. When the unicycle tilts forward a negative torque on the wheel is desired, and vice versa for backwards tilt. However, when looking at correcting both pitch and roll a quadratic policy appears to be required. This can be easily visualised as the flywheel rotating away from the vertical axis within each quadrant. The vertical axis corresponds to a correction in just pitch which is linear. A torque away from this position results in the unicycle moving towards it. This means that the direction of torque required on the flywheel alternates between each quadrant, and is effectively an XOR problem. \cite{roderigo} 
\begin{equation}
\pi (\textbf{x}) = \textbf{x}^T\textbf{Qx} + \textbf{Wx} + \textbf{p}
\label{eq:quad}
\end{equation}
Upon further thought this may not be a problem. The optimal solution may be quadratic but by rotating the other direction the same axis where only pitch is being corrected can be achieved. This can involve a much larger angle of up to $180^{\circ}$ to work. When roll is small the two directions become more similar, and therefore shouldn't pose a problem for most states the unicycle will visit. This non optimal route allows a linear policy to work where two quadrants have the optimal torque direction and two have the sub-optimal direction. Weiser believed that with a linear controller the unicycle learnt to either always fall forward or backwards in order to remain in the optimal regions. \cite{eric}
\newline
Testing using quadratic policies could be performed in future to allow an exact evaluation of using a linear approximation. This approximation is useful because the policy parameters optimised over are greatly reduced in a linear model. Therefore training speed is far quicker.
\subsubsection{Exploration}
During simulated rollouts it became clear that it was likely policy optimisation could plateau. After this only minor improvements to trajectories were made. This may be caused by a linear policy being inadequate and therefore only so much progress is possible, normally resulting in trajectories drifting around the origin.
\newline
Another possible fix is to introduce policy exploration. Currently the policy iteratively optimised based off observed data, called exploitative learning. This means that local optimum can stop learning, and unvisited areas of the state space will not be explored. Exploring these areas, or jumping outside of current policy optimisations may be required to effectively learn the problem, even if this requires additional computation time. 
\newline
Various systems for this exploration exist within the PILCO repository. One particularly interesting method involves fantasising how data collected from new regions could reduce model uncertainty and therefore allow smart exploration to occur. \cite{exp}
\newline
Implementing methods such as this could prove vital to success on the real unicycle.
\subsubsection{Removing Matlab from rollouts}
Currently the unicycle is incapable of running independent from a computer. This is slightly impractical and additional wires may become a nuisance if balancing is achieved. For these reasons it may be beneficial to remove the need for a computer and Matlab script during rollouts. This would require writing the policy function onto the Pi, allow trajectory, and policy transfer onto the Pi, and using a UDP port between phone and Pi.
%----------------------------

%------------------------------------------------------------------------
\clearpage


\begin{thebibliography}{56}
\bibitem[1990. Vos, Von Flotow]{other3}
D. W. Vos and A. H. Von Flotow, ''Dynamics and nonlinear adaptive control of an
autonomous unicycle: Theory and experiment,'' in 29th IEEE Conference on Decision
and Control, pp. 182{187, IEEE, 1990.}

\bibitem[2005. Mellors, Lamb, Maciejowski]{original}
Mark Mellors and Andrew Lamb and J Maciejowski. ,
 2005 ,
 \url{roboticunicycle.info} 
 
\bibitem[2008. D'Souza-Mathew]{neil}
Neil D'Souza-Mathew. ,
 ''Balancing of a Robotic Unicycle''. ,
 MEng Thesis. CUED. ,
 2008,
  \url{roboticunicycle.info/documents/MyFinalReport.pdf}


\bibitem[2009. Forster]{forster}
David Forster. ''Robotic Unicycle'' MEng Thesis. CUED. 2009

\bibitem[2010. McHutchon]{mchut}
Andrew McHutchon, ''Machine learning for Control''. MEng Thesis. CUED. 2010

\bibitem[2011. Rasmussen, Deisenroth]{pilco} 
M. P. Deisenroth and C. E. Rasmussen. , ''PILCO: A Model-based and Data-Efficient Approach to Policy Search''. ,
2011.,
 \url{http://www.icml-2011.org/papers/323_icmlpaper.pdf.}


\bibitem[2011. Rodrigo]{roderigo}
Rodrigo Queiro. ''Machine Learning for Control''. MEng Thesis. CUED. 2011
\url{https://github.com/drigz/IIB-Project/blob/master/iibproject.pdf}

\bibitem[2011. Douglass]{douglass}
Alan Douglass. ''Machine Learning for Control''. MEng Thesis. CUED. 2011

\bibitem[2012. mhexrobot]{other1}
mhexrobot. 2012. \url{https://edgetriggered.wordpress.com/category/unicycle-robot/}

\bibitem[2012. Daoxiong, Qi, Guoyu, Xinghui]{other2}
G. Daoxiong, P. Qi, Z. Guoyu, and L. Xinghui, ''Lqr control for a self-balancing unicycle
robot on inclined plane''. 2012.

\bibitem[2013. Hamlin]{interrupt}
Jay Hamlin. 2013. \url{https://www.raspberrypi.org/forums/viewtopic.php?f=72&t=33880}
 
\bibitem[2016. Mcallister]{exp}
Rowan McAllister. 2016. ''Predicting Next-Step Loss Distributions in PILCO''

\bibitem[2016. Tukiainen]{tuk}
Aleksi Tukiainen. ''The Self-Learning Unicycle''. MEng Thesis. CUED, 2016.

\bibitem[2017. Weiser]{eric}
Eric Weiser. ''Robotic Unicycle'' . MEng Thesis. CUED. 2017

\bibitem[2019. Harris]{arsalan}
Arsalan Harris. ''Robotic Unicycle'' . MEng Thesis. CUED. 2019
 
\bibitem[2019. Davis]{other4}
Matthew Davis. 2019 \url{https://www.mdavis.xyz/unicycle/}



\phantom{please be invisible}
\centerline{\bfseries Software and Hardware} 

\bibitem{ianovir} 
Ianovir: HyperIMU app 
\url{ianovir.com/works/mobile/hyperimu/}

\bibitem{foam}
Protective foam. \url{https://www.diy.com/departments/climaflex-polyethylene-foam-pipe-lagging-l-1m-dia-15mm/5413257001143_BQ.prd}

\bibitem{pi}
Matlab support package for Raspberry Pi. \url{https://uk.mathworks.com/help/supportpkg/raspberrypiio/index.html}

\bibitem{motorcmd}
Python library for the pololu dual mc33926 motor driver for raspberry pi.. \url{https://github.com/pololu/dual-mc33926-motor-driver-rpi.Accessed:23-05-2019}

\bibitem{bike}
Phone mount. \url{https://www.amazon.co.uk/dp/B07GQLYPZZ/ref=cm_sw_em_r_mt_dp_U_hfBXEbFJZDY22}

\bibitem{motor}
Maxom Motors. \url{https://www.maxongroup.com/maxon/view/product/110134}

\bibitem{gear}
Maxon Planetary Gears 1:14. \url{https://www.maxongroup.com/maxon/view/product/134158}

\bibitem{encoder}
Maxom encoder - 512 pulses/rev. \url{https://www.maxongroup.com/maxon/view/product/sensor/encoder/Magnetische-Encoder/ENCODERMR/ENCODER-MR-TYPM-128-512IMP-2-3KANAL/201937}

\end{thebibliography}



%--------------------------------------------------
\clearpage
\section{Appendix}
\subsection{Risk Assessment Review}

\clearpage
\subsection{Covid-19}



%------------------------------------------------

%------------------------------------------------
\end{document}
